#include "gl_renderer.hpp"
#include <algorithm>
#include <cstring>

namespace gl {

// Simple 6x10 bitmap font (ASCII 32-126)
// Each character is 6 pixels wide, 10 pixels tall
// Stored as 10 bytes per character, each byte is a row with 6 bits used
static const uint8_t FONT_DATA[][10] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // space
    {0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x08,0x00,0x00}, // !
    {0x14,0x14,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // "
    {0x14,0x14,0x3E,0x14,0x3E,0x14,0x14,0x00,0x00,0x00}, // #
    {0x08,0x1E,0x28,0x1C,0x0A,0x3C,0x08,0x00,0x00,0x00}, // $
    {0x30,0x32,0x04,0x08,0x10,0x26,0x06,0x00,0x00,0x00}, // %
    {0x18,0x24,0x28,0x10,0x2A,0x24,0x1A,0x00,0x00,0x00}, // &
    {0x08,0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // '
    {0x04,0x08,0x10,0x10,0x10,0x08,0x04,0x00,0x00,0x00}, // (
    {0x10,0x08,0x04,0x04,0x04,0x08,0x10,0x00,0x00,0x00}, // )
    {0x00,0x08,0x2A,0x1C,0x2A,0x08,0x00,0x00,0x00,0x00}, // *
    {0x00,0x08,0x08,0x3E,0x08,0x08,0x00,0x00,0x00,0x00}, // +
    {0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x10,0x00,0x00}, // ,
    {0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x00,0x00,0x00}, // -
    {0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00}, // .
    {0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x00,0x00,0x00}, // /
    {0x1C,0x22,0x26,0x2A,0x32,0x22,0x1C,0x00,0x00,0x00}, // 0
    {0x08,0x18,0x08,0x08,0x08,0x08,0x1C,0x00,0x00,0x00}, // 1
    {0x1C,0x22,0x02,0x0C,0x10,0x20,0x3E,0x00,0x00,0x00}, // 2
    {0x1C,0x22,0x02,0x0C,0x02,0x22,0x1C,0x00,0x00,0x00}, // 3
    {0x04,0x0C,0x14,0x24,0x3E,0x04,0x04,0x00,0x00,0x00}, // 4
    {0x3E,0x20,0x3C,0x02,0x02,0x22,0x1C,0x00,0x00,0x00}, // 5
    {0x0C,0x10,0x20,0x3C,0x22,0x22,0x1C,0x00,0x00,0x00}, // 6
    {0x3E,0x02,0x04,0x08,0x10,0x10,0x10,0x00,0x00,0x00}, // 7
    {0x1C,0x22,0x22,0x1C,0x22,0x22,0x1C,0x00,0x00,0x00}, // 8
    {0x1C,0x22,0x22,0x1E,0x02,0x04,0x18,0x00,0x00,0x00}, // 9
    {0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x00,0x00}, // :
    {0x00,0x00,0x08,0x00,0x00,0x08,0x08,0x10,0x00,0x00}, // ;
    {0x02,0x04,0x08,0x10,0x08,0x04,0x02,0x00,0x00,0x00}, // <
    {0x00,0x00,0x3E,0x00,0x3E,0x00,0x00,0x00,0x00,0x00}, // =
    {0x20,0x10,0x08,0x04,0x08,0x10,0x20,0x00,0x00,0x00}, // >
    {0x1C,0x22,0x02,0x04,0x08,0x00,0x08,0x00,0x00,0x00}, // ?
    {0x1C,0x22,0x2E,0x2A,0x2E,0x20,0x1C,0x00,0x00,0x00}, // @
    {0x08,0x14,0x22,0x22,0x3E,0x22,0x22,0x00,0x00,0x00}, // A
    {0x3C,0x22,0x22,0x3C,0x22,0x22,0x3C,0x00,0x00,0x00}, // B
    {0x1C,0x22,0x20,0x20,0x20,0x22,0x1C,0x00,0x00,0x00}, // C
    {0x38,0x24,0x22,0x22,0x22,0x24,0x38,0x00,0x00,0x00}, // D
    {0x3E,0x20,0x20,0x3C,0x20,0x20,0x3E,0x00,0x00,0x00}, // E
    {0x3E,0x20,0x20,0x3C,0x20,0x20,0x20,0x00,0x00,0x00}, // F
    {0x1C,0x22,0x20,0x2E,0x22,0x22,0x1E,0x00,0x00,0x00}, // G
    {0x22,0x22,0x22,0x3E,0x22,0x22,0x22,0x00,0x00,0x00}, // H
    {0x1C,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,0x00,0x00}, // I
    {0x02,0x02,0x02,0x02,0x22,0x22,0x1C,0x00,0x00,0x00}, // J
    {0x22,0x24,0x28,0x30,0x28,0x24,0x22,0x00,0x00,0x00}, // K
    {0x20,0x20,0x20,0x20,0x20,0x20,0x3E,0x00,0x00,0x00}, // L
    {0x22,0x36,0x2A,0x2A,0x22,0x22,0x22,0x00,0x00,0x00}, // M
    {0x22,0x32,0x2A,0x26,0x22,0x22,0x22,0x00,0x00,0x00}, // N
    {0x1C,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,0x00,0x00}, // O
    {0x3C,0x22,0x22,0x3C,0x20,0x20,0x20,0x00,0x00,0x00}, // P
    {0x1C,0x22,0x22,0x22,0x2A,0x24,0x1A,0x00,0x00,0x00}, // Q
    {0x3C,0x22,0x22,0x3C,0x28,0x24,0x22,0x00,0x00,0x00}, // R
    {0x1C,0x22,0x20,0x1C,0x02,0x22,0x1C,0x00,0x00,0x00}, // S
    {0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00}, // T
    {0x22,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,0x00,0x00}, // U
    {0x22,0x22,0x22,0x22,0x14,0x14,0x08,0x00,0x00,0x00}, // V
    {0x22,0x22,0x22,0x2A,0x2A,0x36,0x22,0x00,0x00,0x00}, // W
    {0x22,0x22,0x14,0x08,0x14,0x22,0x22,0x00,0x00,0x00}, // X
    {0x22,0x22,0x14,0x08,0x08,0x08,0x08,0x00,0x00,0x00}, // Y
    {0x3E,0x02,0x04,0x08,0x10,0x20,0x3E,0x00,0x00,0x00}, // Z
    {0x1C,0x10,0x10,0x10,0x10,0x10,0x1C,0x00,0x00,0x00}, // [
    {0x00,0x20,0x10,0x08,0x04,0x02,0x00,0x00,0x00,0x00}, // backslash
    {0x1C,0x04,0x04,0x04,0x04,0x04,0x1C,0x00,0x00,0x00}, // ]
    {0x08,0x14,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // ^
    {0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x00,0x00,0x00}, // _
    {0x10,0x08,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // `
    {0x00,0x00,0x1C,0x02,0x1E,0x22,0x1E,0x00,0x00,0x00}, // a
    {0x20,0x20,0x3C,0x22,0x22,0x22,0x3C,0x00,0x00,0x00}, // b
    {0x00,0x00,0x1C,0x22,0x20,0x22,0x1C,0x00,0x00,0x00}, // c
    {0x02,0x02,0x1E,0x22,0x22,0x22,0x1E,0x00,0x00,0x00}, // d
    {0x00,0x00,0x1C,0x22,0x3E,0x20,0x1C,0x00,0x00,0x00}, // e
    {0x0C,0x12,0x10,0x3C,0x10,0x10,0x10,0x00,0x00,0x00}, // f
    {0x00,0x00,0x1E,0x22,0x22,0x1E,0x02,0x1C,0x00,0x00}, // g
    {0x20,0x20,0x3C,0x22,0x22,0x22,0x22,0x00,0x00,0x00}, // h
    {0x08,0x00,0x18,0x08,0x08,0x08,0x1C,0x00,0x00,0x00}, // i
    {0x04,0x00,0x0C,0x04,0x04,0x04,0x24,0x18,0x00,0x00}, // j
    {0x20,0x20,0x22,0x24,0x38,0x24,0x22,0x00,0x00,0x00}, // k
    {0x18,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,0x00,0x00}, // l
    {0x00,0x00,0x34,0x2A,0x2A,0x2A,0x22,0x00,0x00,0x00}, // m
    {0x00,0x00,0x3C,0x22,0x22,0x22,0x22,0x00,0x00,0x00}, // n
    {0x00,0x00,0x1C,0x22,0x22,0x22,0x1C,0x00,0x00,0x00}, // o
    {0x00,0x00,0x3C,0x22,0x22,0x3C,0x20,0x20,0x00,0x00}, // p
    {0x00,0x00,0x1E,0x22,0x22,0x1E,0x02,0x02,0x00,0x00}, // q
    {0x00,0x00,0x2E,0x30,0x20,0x20,0x20,0x00,0x00,0x00}, // r
    {0x00,0x00,0x1E,0x20,0x1C,0x02,0x3C,0x00,0x00,0x00}, // s
    {0x10,0x10,0x3C,0x10,0x10,0x12,0x0C,0x00,0x00,0x00}, // t
    {0x00,0x00,0x22,0x22,0x22,0x26,0x1A,0x00,0x00,0x00}, // u
    {0x00,0x00,0x22,0x22,0x22,0x14,0x08,0x00,0x00,0x00}, // v
    {0x00,0x00,0x22,0x22,0x2A,0x2A,0x14,0x00,0x00,0x00}, // w
    {0x00,0x00,0x22,0x14,0x08,0x14,0x22,0x00,0x00,0x00}, // x
    {0x00,0x00,0x22,0x22,0x22,0x1E,0x02,0x1C,0x00,0x00}, // y
    {0x00,0x00,0x3E,0x04,0x08,0x10,0x3E,0x00,0x00,0x00}, // z
    {0x04,0x08,0x08,0x10,0x08,0x08,0x04,0x00,0x00,0x00}, // {
    {0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00}, // |
    {0x10,0x08,0x08,0x04,0x08,0x08,0x10,0x00,0x00,0x00}, // }
    {0x00,0x00,0x10,0x2A,0x04,0x00,0x00,0x00,0x00,0x00}, // ~
};

Renderer::Renderer() {}

Renderer::~Renderer() {
    shutdown();
}

bool Renderer::initialize(int width, int height) {
    width_ = width;
    height_ = height;
    initialized_ = true;
    
    // OpenGL setup with antialiasing
    glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    // Enable antialiasing for lines and polygons
    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_POLYGON_SMOOTH);
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
    
    // Enable multisampling if available (GL_MULTISAMPLE = 0x809D)
    glEnable(0x809D);
    
    return true;
}

void Renderer::resize(int width, int height) {
    width_ = width;
    height_ = height;
}

void Renderer::shutdown() {
    initialized_ = false;
}

void Renderer::beginFrame() {
    glViewport(0, 0, width_, height_);
    
    // Set up orthographic projection
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, width_, height_, 0, -1, 1);  // Top-left origin like raylib
    
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

void Renderer::endFrame() {
    glFlush();
}

void Renderer::setColor(Color color) {
    glColor4ub(color.r, color.g, color.b, color.a);
}

void Renderer::clearBackground(Color color) {
    glClearColor(color.r / 255.0f, color.g / 255.0f, color.b / 255.0f, color.a / 255.0f);
    glClear(GL_COLOR_BUFFER_BIT);
}

void Renderer::drawRectangle(int x, int y, int w, int h, Color color) {
    setColor(color);
    glBegin(GL_QUADS);
    glVertex2i(x, y);
    glVertex2i(x + w, y);
    glVertex2i(x + w, y + h);
    glVertex2i(x, y + h);
    glEnd();
}

void Renderer::drawRectangleRec(Rectangle rec, Color color) {
    drawRectangle(static_cast<int>(rec.x), static_cast<int>(rec.y), 
                  static_cast<int>(rec.width), static_cast<int>(rec.height), color);
}

void Renderer::drawRoundedCorner(float cx, float cy, float radius, float startAngle, int segments, Color color) {
    setColor(color);
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(cx, cy);
    for (int i = 0; i <= segments; ++i) {
        float angle = startAngle + (PI / 2.0f) * i / segments;
        glVertex2f(cx + std::cos(angle) * radius, cy + std::sin(angle) * radius);
    }
    glEnd();
}

void Renderer::drawRectangleRounded(Rectangle rec, float roundness, int segments, Color color) {
    if (roundness <= 0.0f || rec.width < 2.0f || rec.height < 2.0f) {
        drawRectangleRec(rec, color);
        return;
    }
    
    float radius = (std::min)(rec.width, rec.height) * roundness * 0.5f;
    radius = (std::min)(radius, (std::min)(rec.width, rec.height) * 0.5f);
    
    setColor(color);
    
    // Center rectangle
    glBegin(GL_QUADS);
    glVertex2f(rec.x + radius, rec.y);
    glVertex2f(rec.x + rec.width - radius, rec.y);
    glVertex2f(rec.x + rec.width - radius, rec.y + rec.height);
    glVertex2f(rec.x + radius, rec.y + rec.height);
    glEnd();
    
    // Left rectangle
    glBegin(GL_QUADS);
    glVertex2f(rec.x, rec.y + radius);
    glVertex2f(rec.x + radius, rec.y + radius);
    glVertex2f(rec.x + radius, rec.y + rec.height - radius);
    glVertex2f(rec.x, rec.y + rec.height - radius);
    glEnd();
    
    // Right rectangle
    glBegin(GL_QUADS);
    glVertex2f(rec.x + rec.width - radius, rec.y + radius);
    glVertex2f(rec.x + rec.width, rec.y + radius);
    glVertex2f(rec.x + rec.width, rec.y + rec.height - radius);
    glVertex2f(rec.x + rec.width - radius, rec.y + rec.height - radius);
    glEnd();
    
    // Corners
    int segs = (std::max)(4, segments);
    drawRoundedCorner(rec.x + radius, rec.y + radius, radius, PI, segs, color);
    drawRoundedCorner(rec.x + rec.width - radius, rec.y + radius, radius, -PI/2, segs, color);
    drawRoundedCorner(rec.x + rec.width - radius, rec.y + rec.height - radius, radius, 0, segs, color);
    drawRoundedCorner(rec.x + radius, rec.y + rec.height - radius, radius, PI/2, segs, color);
}

void Renderer::drawRectangleRoundedLines(Rectangle rec, float roundness, int segments, Color color) {
    if (roundness <= 0.0f) {
        drawRectangleLines(static_cast<int>(rec.x), static_cast<int>(rec.y), 
                          static_cast<int>(rec.width), static_cast<int>(rec.height), color);
        return;
    }
    
    float radius = (std::min)(rec.width, rec.height) * roundness * 0.5f;
    radius = (std::min)(radius, (std::min)(rec.width, rec.height) * 0.5f);
    
    setColor(color);
    glBegin(GL_LINE_LOOP);
    
    int segs = (std::max)(4, segments);
    
    // Top-left corner
    for (int i = 0; i <= segs; ++i) {
        float angle = PI + (PI / 2) * i / segs;
        glVertex2f(rec.x + radius + std::cos(angle) * radius, 
                   rec.y + radius + std::sin(angle) * radius);
    }
    
    // Top-right corner
    for (int i = 0; i <= segs; ++i) {
        float angle = -PI/2 + (PI / 2) * i / segs;
        glVertex2f(rec.x + rec.width - radius + std::cos(angle) * radius, 
                   rec.y + radius + std::sin(angle) * radius);
    }
    
    // Bottom-right corner
    for (int i = 0; i <= segs; ++i) {
        float angle = 0 + (PI / 2) * i / segs;
        glVertex2f(rec.x + rec.width - radius + std::cos(angle) * radius, 
                   rec.y + rec.height - radius + std::sin(angle) * radius);
    }
    
    // Bottom-left corner
    for (int i = 0; i <= segs; ++i) {
        float angle = PI/2 + (PI / 2) * i / segs;
        glVertex2f(rec.x + radius + std::cos(angle) * radius, 
                   rec.y + rec.height - radius + std::sin(angle) * radius);
    }
    
    glEnd();
}

void Renderer::drawRectangleLines(int x, int y, int w, int h, Color color) {
    setColor(color);
    glBegin(GL_LINE_LOOP);
    glVertex2i(x, y);
    glVertex2i(x + w, y);
    glVertex2i(x + w, y + h);
    glVertex2i(x, y + h);
    glEnd();
}

void Renderer::drawRectangleGradientV(int x, int y, int w, int h, Color top, Color bottom) {
    glBegin(GL_QUADS);
    glColor4ub(top.r, top.g, top.b, top.a);
    glVertex2i(x, y);
    glVertex2i(x + w, y);
    glColor4ub(bottom.r, bottom.g, bottom.b, bottom.a);
    glVertex2i(x + w, y + h);
    glVertex2i(x, y + h);
    glEnd();
}

void Renderer::drawLine(int x1, int y1, int x2, int y2, Color color) {
    setColor(color);
    glBegin(GL_LINES);
    glVertex2i(x1, y1);
    glVertex2i(x2, y2);
    glEnd();
}

void Renderer::drawLineEx(Vector2 start, Vector2 end, float thick, Color color) {
    if (thick <= 1.0f) {
        drawLine(static_cast<int>(start.x), static_cast<int>(start.y),
                static_cast<int>(end.x), static_cast<int>(end.y), color);
        return;
    }
    
    float dx = end.x - start.x;
    float dy = end.y - start.y;
    float len = std::sqrt(dx * dx + dy * dy);
    if (len < 0.001f) return;
    
    float nx = -dy / len * thick * 0.5f;
    float ny = dx / len * thick * 0.5f;
    
    setColor(color);
    glBegin(GL_QUADS);
    glVertex2f(start.x + nx, start.y + ny);
    glVertex2f(end.x + nx, end.y + ny);
    glVertex2f(end.x - nx, end.y - ny);
    glVertex2f(start.x - nx, start.y - ny);
    glEnd();
}

void Renderer::drawCircle(int cx, int cy, float radius, Color color) {
    int segments = (std::max)(12, static_cast<int>(radius * 0.5f));
    setColor(color);
    glBegin(GL_TRIANGLE_FAN);
    glVertex2i(cx, cy);
    for (int i = 0; i <= segments; ++i) {
        float angle = 2.0f * PI * i / segments;
        glVertex2f(cx + std::cos(angle) * radius, cy + std::sin(angle) * radius);
    }
    glEnd();
}

void Renderer::drawCircleLines(int cx, int cy, float radius, Color color) {
    int segments = (std::max)(12, static_cast<int>(radius * 0.5f));
    setColor(color);
    glBegin(GL_LINE_LOOP);
    for (int i = 0; i < segments; ++i) {
        float angle = 2.0f * PI * i / segments;
        glVertex2f(cx + std::cos(angle) * radius, cy + std::sin(angle) * radius);
    }
    glEnd();
}

void Renderer::drawCircleGradient(int cx, int cy, float radius, Color inner, Color outer) {
    int segments = (std::max)(12, static_cast<int>(radius * 0.5f));
    glBegin(GL_TRIANGLE_FAN);
    glColor4ub(inner.r, inner.g, inner.b, inner.a);
    glVertex2i(cx, cy);
    glColor4ub(outer.r, outer.g, outer.b, outer.a);
    for (int i = 0; i <= segments; ++i) {
        float angle = 2.0f * PI * i / segments;
        glVertex2f(cx + std::cos(angle) * radius, cy + std::sin(angle) * radius);
    }
    glEnd();
}

void Renderer::drawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color) {
    setColor(color);
    glBegin(GL_TRIANGLES);
    glVertex2f(v1.x, v1.y);
    glVertex2f(v2.x, v2.y);
    glVertex2f(v3.x, v3.y);
    glEnd();
}

void Renderer::drawText(const char* text, int x, int y, int fontSize, Color color) {
    if (!text) return;
    
    float scale = fontSize / 10.0f;  // Base font is 10px tall
    int cursorX = x;
    
    setColor(color);
    
    for (const char* p = text; *p; ++p) {
        int charIndex = static_cast<int>(*p) - 32;
        if (charIndex < 0 || charIndex >= 95) charIndex = 0;  // Default to space
        
        const uint8_t* charData = FONT_DATA[charIndex];
        
        for (int row = 0; row < 10; ++row) {
            uint8_t rowBits = charData[row];
            for (int col = 0; col < 6; ++col) {
                if (rowBits & (0x20 >> col)) {
                    float px = cursorX + col * scale;
                    float py = y + row * scale;
                    
                    glBegin(GL_QUADS);
                    glVertex2f(px, py);
                    glVertex2f(px + scale, py);
                    glVertex2f(px + scale, py + scale);
                    glVertex2f(px, py + scale);
                    glEnd();
                }
            }
        }
        
        cursorX += static_cast<int>(FONT_CHAR_WIDTH * scale);
    }
}

int Renderer::measureText(const char* text, int fontSize) {
    if (!text) return 0;
    float scale = fontSize / 10.0f;
    return static_cast<int>(std::strlen(text) * FONT_CHAR_WIDTH * scale);
}

Color Renderer::fade(Color color, float alpha) {
    return Color(color.r, color.g, color.b, 
                 static_cast<uint8_t>(color.a * (std::max)(0.0f, (std::min)(1.0f, alpha))));
}

Color Renderer::lerpColor(Color a, Color b, float t) {
    t = (std::max)(0.0f, (std::min)(1.0f, t));
    return Color(
        static_cast<uint8_t>(a.r + (b.r - a.r) * t),
        static_cast<uint8_t>(a.g + (b.g - a.g) * t),
        static_cast<uint8_t>(a.b + (b.b - a.b) * t),
        static_cast<uint8_t>(a.a + (b.a - a.a) * t)
    );
}

bool Renderer::checkCollisionPointRec(Vector2 point, Rectangle rec) {
    return point.x >= rec.x && point.x <= rec.x + rec.width &&
           point.y >= rec.y && point.y <= rec.y + rec.height;
}

} // namespace gl

